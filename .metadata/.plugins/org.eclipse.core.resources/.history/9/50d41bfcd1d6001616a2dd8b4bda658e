package org.team537.robot.subsystems;

import org.team537.robot.RobotMap;
import org.team537.robot.commands.SwerveDefault;
import org.team537.toolbox.Maths;

import com.ctre.CANTalon;
import com.ctre.CANTalon.FeedbackDevice;
import com.ctre.CANTalon.TalonControlMode;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

public class Drive extends Subsystem {
	private final DriveModule backLeft = new DriveModule(
			"Back Left", 
			new CANTalon(RobotMap.CAN.DRIVE_BACK_LEFT_ANGLE), 
			new CANTalon(RobotMap.CAN.DRIVE_BACK_LEFT_DRIVE), 
			2.0, 0.0, 1.0
	);

	private final DriveModule backRight = new DriveModule(
			"Back Right", 
			new CANTalon(RobotMap.CAN.DRIVE_BACK_RIGHT_ANGLE), 
			new CANTalon(RobotMap.CAN.DRIVE_BACK_RIGHT_DRIVE), 
			2.0, 0.0, 1.0
	);

	private final DriveModule frontLeft = new DriveModule(
			"Front Left", 
			new CANTalon(RobotMap.CAN.DRIVE_FRONT_LEFT_ANGLE), 
			new CANTalon(RobotMap.CAN.DRIVE_FRONT_LEFT_DRIVE), 
			2.0, 0.0, 1.0
	);

	private final DriveModule frontRight = new DriveModule(
			"Front Right", 
			new CANTalon(RobotMap.CAN.DRIVE_FRONT_RIGHT_ANGLE), 
			new CANTalon(RobotMap.CAN.DRIVE_FRONT_RIGHT_DRIVE), 
			2.0, 0.0, 1.0
	);

	public Drive() {
	}

	@Override
	protected void initDefaultCommand() {
		setDefaultCommand(new SwerveDefault());
	}
	
	public void dashboard() {
		backLeft.dashboard();
		backRight.dashboard();
		frontLeft.dashboard();
		frontRight.dashboard();
	}
	
	public void drive(double rotation, double strafe, double forward, double gyro) {
		// Logs swerve inputs.
		SmartDashboard.putNumber("Drive Input Rotation", rotation);
		SmartDashboard.putNumber("Drive Input Strafe", strafe);
		SmartDashboard.putNumber("Drive Input Forward", forward);
		SmartDashboard.putNumber("Drive Input Gyro", gyro);
		
		// Calculates forward and strafes using the gyro to field orient.
		double fwd2 = (forward * Math.cos(gyro)) + strafe * Math.sin(gyro);
		double str2 = (-forward * Math.sin(gyro)) + strafe * Math.cos(gyro);

		// Calculates inverse kinematics values.
		double r = RobotMap.Robot.RATIO * 0.5;
		double a = str2 - rotation * ((RobotMap.Robot.LENGTH / r) * 0.5);
		double b = str2 + rotation * ((RobotMap.Robot.LENGTH / r) * 0.5);
		double c = fwd2 - rotation * ((RobotMap.Robot.WIDTH / r) * 0.5);
		double d = fwd2 + rotation * ((RobotMap.Robot.WIDTH / r) * 0.5);

		// Calculates speeds from kinematic values.
		double frs = Math.sqrt((b * b) + (c * c));
		double fls = Math.sqrt((a * a) + (c * c));
		double bls = Math.sqrt((a * a) + (d * d));
		double brs = Math.sqrt((b * b) + (d * d));
		
		// Normalizes the speeds.
		double max = Maths.maxValue(frs, fls, bls, brs);

		if (max > 1.0) {
			frs /= max;
			fls /= max;
			bls /= max;
			brs /= max;
		}

		// Calculates angles from kinematic values.
		double fra = Math.atan2(b, c) * (180.0 / Math.PI);
		double fla = Math.atan2(a, c) * (180.0 / Math.PI);
		double bla = Math.atan2(a, d) * (180.0 / Math.PI);
		double bra = Math.atan2(b, d) * (180.0 / Math.PI);

		// Updates the modules with new speeds and angles.
		frontRight.update(frs, fra); 
		frontLeft.update(fls, fla);
		backLeft.update(bls, bla);
		backRight.update(brs, bra); 
	}
	
	public void reset() {
		backLeft.reset();
		backRight.reset();
		frontLeft.reset();
		frontRight.reset();
	//	Robot.ahrs.reset();
	}
	
	public void stop() {
		backLeft.stop();
		backRight.stop();
		frontLeft.stop();
		frontRight.stop();
	}
	
	public static class DriveModule {
		private String name;
		private CANTalon angle;
		private CANTalon drive;
		private int potMin, potMax, potRange, potOffset;
		
		public DriveModule(String name, CANTalon angle, CANTalon drive, double p, double i, double d) {
			this.name = name;
			this.angle = angle;
			this.drive = drive;
			this.potMin = 15;
			this.potMax = 345;
			this.potRange = potMax - potMin;
			this.potOffset = 0;

			this.angle.setFeedbackDevice(FeedbackDevice.AnalogPot);
			this.angle.changeControlMode(TalonControlMode.Position);
			this.angle.setPID(p, i, d);
			this.angle.enable();
			
			this.drive.setFeedbackDevice(FeedbackDevice.QuadEncoder);
			this.drive.changeControlMode(TalonControlMode.PercentVbus);
			this.drive.enable();
		}
		
		public void update(double speed, double angle) {
			// Logs module inputs.
			SmartDashboard.putNumber(name + " Set Speed", speed);
			SmartDashboard.putNumber(name + " Set Angle", angle);

			// Updates current pot bounds.
			int potCurrent = this.angle.getAnalogInRaw();
			
			if (potCurrent < potMin) {
				potMin = potCurrent;
			}
			
			if (potCurrent > potMax) {
				potMax = potCurrent;
			}
			
			potRange = potMax - potMin;
			
			// Moves the module to the angle and at a speed.
			angle = Maths.normalizeAngle(angle);
			angle = ((angle / 360.0) * (potMax - potMin)) + potMin;
			angle += potOffset;
			angle += potRange;
			
			if (angle > potMax) {
				angle -= potRange;
			}
			
			if (angle < potMin) {
				angle += potRange;
			}
			
			this.angle.set(angle);
			
			if (RobotMap.Robot.DRIVE_ENABLED && Maths.deadband(RobotMap.Robot.DRIVE_SPEED_MIN, speed) != 0) {
				this.drive.set(RobotMap.Robot.DRIVE_SPEED * speed * 12.0);
			} else {
				this.drive.set(0.0);
			}
		}
		
		public void dashboard() {
			SmartDashboard.putNumber(name + " Drive Speed", drive.getSpeed());
			SmartDashboard.putNumber(name + " Drive Position", drive.getEncPosition());
			SmartDashboard.putNumber(name + " Pot Current", angle.getAnalogInRaw());
			SmartDashboard.putNumber(name + " Pot Min", potMin);
			SmartDashboard.putNumber(name + " Pot Max", potMax);
			SmartDashboard.putNumber(name + " Pot Range", potRange);
			SmartDashboard.putNumber(name + " Pot Offset", potOffset);
		}
		
		public void reset() {
			angle.enable();
			drive.enable();

			angle.set(0.0);
			drive.set(0.0);
			drive.setPosition(0.0);
		}
		
		public void stop() {
			drive.set(0.0);
		}
	}
}
